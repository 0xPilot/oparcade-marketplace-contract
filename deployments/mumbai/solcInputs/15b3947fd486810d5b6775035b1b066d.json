{
  "language": "Solidity",
  "sources": {
    "contracts/AddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract AddressRegistry is Initializable, OwnableUpgradeable {\n  event TokenRegistryUpdated(address indexed by, address indexed oldTokenRegistry, address indexed newTokenRegistry);\n  event MarketplaceUpdated(address indexed by, address indexed oldMarketplace, address indexed newMarketplace);\n  event AuctionUpdated(address indexed by, address indexed oldAuction, address indexed newAuction);\n\n  /// @notice TokenRegistry contract\n  address public tokenRegistry;\n\n  /// @notice Marketplace contract\n  address public marketplace;\n\n  /// @notice Auction contract\n  address public auction;\n\n  function initialize() external initializer {\n    __Ownable_init();\n  }\n\n  /**\n   @notice Update TokenRegistry contract\n   @dev Only owner\n   @param _tokenRegistry new TokenRegistry contract address\n   */\n  function updateTokenRegistry(address _tokenRegistry) external onlyOwner {\n    emit TokenRegistryUpdated(msg.sender, tokenRegistry, _tokenRegistry);\n\n    tokenRegistry = _tokenRegistry;\n  }\n\n  /**\n   @notice Update Marketplace contract\n   @dev Only owner\n   @param _marketplace new Marketplace contract address\n   */\n  function updateMarketplace(address _marketplace) external onlyOwner {\n    emit MarketplaceUpdated(msg.sender, marketplace, _marketplace);\n\n    marketplace = _marketplace;\n  }\n\n  /**\n   @notice Update Auction contract\n   @dev Only owner\n   @param _auction new Auction contract address\n   */\n  function updateAuction(address _auction) external onlyOwner {\n    emit AuctionUpdated(msg.sender, auction, _auction);\n\n    auction = _auction;\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/TokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\n\ncontract TokenRegistry is Initializable, OwnableUpgradeable {\n  event CollectionAdded(address indexed by, address indexed collection);\n  event CollectionRemoved(address indexed by, address indexed collection);\n  event PayTokenAdded(address indexed by, address indexed token);\n  event PayTokenRemoved(address indexed by, address indexed token);\n\n  bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n  bytes4 private constant INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n  /// @notice NFTAddress -> Bool\n  mapping(address => bool) public enabledCollection;\n\n  /// @notice Token -> Bool\n  mapping(address => bool) public enabledPayToken;\n\n  function initialize() external initializer {\n    __Ownable_init();\n  }\n\n  /**\n   @notice Add NFT collection\n   @dev Only owner\n   @param _nftAddress NFT address\n   */\n  function addCollection(address _nftAddress) external onlyOwner {\n    require(!enabledCollection[_nftAddress], \"collection already added\");\n    require(\n      IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC721) ||\n        IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC1155),\n      \"unexpected collection\"\n    );\n\n    enabledCollection[_nftAddress] = true;\n\n    emit CollectionAdded(msg.sender, _nftAddress);\n  }\n\n  /**\n   @notice Remove NFT collection\n   @dev Only owner\n   @param _nftAddress NFT address\n   */\n  function removeCollection(address _nftAddress) external onlyOwner {\n    require(enabledCollection[_nftAddress], \"collection not exist\");\n\n    enabledCollection[_nftAddress] = false;\n\n    emit CollectionRemoved(msg.sender, _nftAddress);\n  }\n\n  /**\n   @notice Add payment token\n   @dev Only owner\n   @param _token ERC20 token address\n   */\n  function addPayToken(address _token) external onlyOwner {\n    require(!enabledPayToken[_token], \"token already added\");\n    require(_token != address(0), \"zero token address\");\n\n    enabledPayToken[_token] = true;\n\n    emit PayTokenAdded(msg.sender, _token);\n  }\n\n  /**\n   @notice Remove payment token\n   @dev Only owner\n   @param _token ERC20 token address\n   */\n  function removePayToken(address _token) external onlyOwner {\n    require(enabledPayToken[_token], \"token not exist\");\n\n    enabledPayToken[_token] = false;\n\n    emit PayTokenRemoved(msg.sender, _token);\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/OPGamesMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IOPGamesAuction.sol\";\nimport \"./interfaces/IAddressRegistry.sol\";\nimport \"./interfaces/ITokenRegistry.sol\";\n\ncontract OPGamesMarketplace is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /// @notice Events for the contract\n  event ItemListed(\n    address indexed owner,\n    address indexed nft,\n    uint256 tokenId,\n    uint256 quantity,\n    address payToken,\n    uint256 pricePerItem,\n    uint256 startingTime\n  );\n  event ItemSold(\n    address indexed seller,\n    address indexed buyer,\n    address indexed nft,\n    uint256 tokenId,\n    uint256 quantity,\n    address payToken,\n    uint256 pricePerItem\n  );\n  event ItemUpdated(address indexed owner, address indexed nft, uint256 tokenId, address payToken, uint256 newPrice);\n  event ItemCanceled(address indexed owner, address indexed nft, uint256 tokenId);\n  event OfferCreated(\n    address indexed creator,\n    address indexed nft,\n    uint256 tokenId,\n    uint256 quantity,\n    address payToken,\n    uint256 pricePerItem,\n    uint256 deadline\n  );\n  event OfferCanceled(address indexed creator, address indexed nft, uint256 tokenId);\n  event PlatformFeeUpdated(address indexed by, uint256 oldPlatformFee, uint256 newPlatformFee);\n  event PlatformFeeRecipientUpdated(\n    address indexed by,\n    address indexed oldFeeRecipient,\n    address indexed newFeeRecipient\n  );\n\n  /// @notice Structure for listed items\n  struct Listing {\n    uint256 quantity;\n    address payToken;\n    uint256 pricePerItem;\n    uint256 startAt;\n  }\n\n  /// @notice Structure for offer\n  struct Offer {\n    IERC20Upgradeable payToken;\n    uint256 quantity;\n    uint256 pricePerItem;\n    uint256 deadline;\n  }\n\n  bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n  bytes4 private constant INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n  /// @notice NFT Address -> Token ID -> Owner -> Listing\n  mapping(address => mapping(uint256 => mapping(address => Listing))) public listings;\n\n  /// @notice NFT Address -> Token ID -> Offerer -> Offer\n  mapping(address => mapping(uint256 => mapping(address => Offer))) public offers;\n\n  /// @notice Platform fee recipient\n  address payable public feeRecipient;\n\n  /// @notice Platform fee\n  uint256 public platformFee;\n\n  /// @notice AddressRegistry\n  IAddressRegistry public addressRegistry;\n\n  modifier isListed(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner\n  ) {\n    Listing memory listing = listings[_nftAddress][_tokenId][_owner];\n    require(listing.quantity > 0, \"not listed item\");\n    _;\n  }\n\n  modifier notListed(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner\n  ) {\n    Listing memory listing = listings[_nftAddress][_tokenId][_owner];\n    require(listing.quantity == 0, \"already listed\");\n    _;\n  }\n\n  modifier validListing(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner\n  ) {\n    Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];\n\n    _validOwner(_nftAddress, _tokenId, _owner, listedItem.quantity);\n\n    require(_getNow() >= listedItem.startAt, \"item not buyable\");\n    _;\n  }\n\n  modifier offerExists(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _creator\n  ) {\n    Offer memory offer = offers[_nftAddress][_tokenId][_creator];\n    require(offer.quantity > 0 && offer.deadline > _getNow(), \"offer not exists or expired\");\n    _;\n  }\n\n  modifier offerNotExists(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _creator\n  ) {\n    Offer memory offer = offers[_nftAddress][_tokenId][_creator];\n    require(offer.quantity == 0 || offer.deadline <= _getNow(), \"offer already created\");\n    _;\n  }\n\n  receive() external payable {}\n\n  function initialize(\n    address _addressRegistry,\n    address payable _feeRecipient,\n    uint256 _platformFee\n  ) external initializer {\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    __Pausable_init();\n\n    require(_addressRegistry != address(0), \"unexpected address registry\");\n    require(_feeRecipient != address(0), \"unexpected fee recipient\");\n    require(_platformFee < 100_0, \"platform fee exceeded\");\n\n    addressRegistry = IAddressRegistry(_addressRegistry);\n    feeRecipient = _feeRecipient;\n    platformFee = _platformFee;\n  }\n\n  /**\n   * @notice Method for listing NFT\n   * @param _nftAddress Address of NFT contract\n   * @param _tokenId Token ID of NFT\n   * @param _quantity token amount to list (needed for ERC-1155 NFTs, set as 1 for ERC-721)\n   * @param _payToken Paying token\n   * @param _pricePerItem sale price for each iteam\n   * @param _startAt scheduling for a future sale\n   */\n  function listItem(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _quantity,\n    address _payToken,\n    uint256 _pricePerItem,\n    uint256 _startAt\n  ) external notListed(_nftAddress, _tokenId, msg.sender) {\n    if (IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) {\n      IERC721Upgradeable nft = IERC721Upgradeable(_nftAddress);\n      require(nft.ownerOf(_tokenId) == msg.sender, \"not owning item\");\n      require(nft.isApprovedForAll(msg.sender, address(this)), \"item not approved\");\n    } else if (IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC1155)) {\n      IERC1155Upgradeable nft = IERC1155Upgradeable(_nftAddress);\n      require(nft.balanceOf(msg.sender, _tokenId) >= _quantity, \"must hold enough nfts\");\n      require(nft.isApprovedForAll(msg.sender, address(this)), \"item not approved\");\n    } else {\n      revert(\"invalid nft address\");\n    }\n\n    _validCollection(_nftAddress);\n    _validPayToken(_payToken);\n\n    listings[_nftAddress][_tokenId][msg.sender] = Listing(_quantity, _payToken, _pricePerItem, _startAt);\n\n    emit ItemListed(msg.sender, _nftAddress, _tokenId, _quantity, _payToken, _pricePerItem, _startAt);\n  }\n\n  /**\n   * @notice Method for canceling listed NFT\n   * @param _nftAddress Addres of NFT contract\n   * @param _tokenId Token ID of NFT\n   */\n  function cancelListing(address _nftAddress, uint256 _tokenId)\n    external\n    nonReentrant\n    isListed(_nftAddress, _tokenId, msg.sender)\n  {\n    _cancelListing(_nftAddress, _tokenId, msg.sender);\n  }\n\n  /**\n   * @notice Method for updating listed NFT\n   * @param _nftAddress Address of NFT contract\n   * @param _tokenId Token ID of NFT\n   * @param _payToken Payment token address\n   * @param _newPrice New sale price for each item\n   */\n  function updateListing(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _payToken,\n    uint256 _newPrice\n  ) external nonReentrant isListed(_nftAddress, _tokenId, msg.sender) {\n    Listing storage listedItem = listings[_nftAddress][_tokenId][msg.sender];\n\n    _validOwner(_nftAddress, _tokenId, msg.sender, listedItem.quantity);\n\n    _validPayToken(_payToken);\n\n    listedItem.payToken = _payToken;\n    listedItem.pricePerItem = _newPrice;\n\n    emit ItemUpdated(msg.sender, _nftAddress, _tokenId, _payToken, _newPrice);\n  }\n\n  /**\n   * @notice Method for buying listed NFT\n   * @param _nftAddress Address of NFT contract\n   * @param _tokenId Token ID of NFT\n   * @param _payToken Payment token address\n   * @param _owner NFT owner address\n   */\n  function buyItem(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _payToken,\n    address _owner\n  )\n    external\n    payable\n    nonReentrant\n    whenNotPaused\n    isListed(_nftAddress, _tokenId, _owner)\n    validListing(_nftAddress, _tokenId, _owner)\n  {\n    Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];\n    require(listedItem.payToken == _payToken, \"invalid pay token\");\n\n    _buyItem(_nftAddress, _tokenId, _payToken, _owner);\n  }\n\n  function _buyItem(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _payToken,\n    address _owner\n  ) private {\n    Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];\n\n    uint256 price = listedItem.pricePerItem * listedItem.quantity;\n    uint256 feeAmount = (price * platformFee) / 100_0;\n\n    // Transfer token to owner\n    if (_payToken == address(0)) {\n      require(msg.value == price, \"insufficient Ether to buy\");\n    }\n    _tokenTransferFrom(msg.sender, feeRecipient, _payToken, feeAmount);\n    _tokenTransferFrom(msg.sender, _owner, _payToken, price - feeAmount);\n\n    // Transfer NFT to buyer\n    if (IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) {\n      IERC721Upgradeable(_nftAddress).safeTransferFrom(_owner, msg.sender, _tokenId);\n    } else {\n      IERC1155Upgradeable(_nftAddress).safeTransferFrom(_owner, msg.sender, _tokenId, listedItem.quantity, bytes(\"\"));\n    }\n\n    delete (listings[_nftAddress][_tokenId][_owner]);\n\n    emit ItemSold(_owner, msg.sender, _nftAddress, _tokenId, listedItem.quantity, _payToken, listedItem.pricePerItem);\n  }\n\n  /**\n   * @notice Method of offering item\n   * @param _nftAddress Addres of NFT contract\n   * @param _tokenId Token ID of NFT\n   * @param _payToken Payment tokne addres\n   * @param _quantity Quantity of items\n   * @param _pricePerItem Price per item\n   * @param _deadline Offer expiration\n   */\n  function createOffer(\n    address _nftAddress,\n    uint256 _tokenId,\n    IERC20Upgradeable _payToken,\n    uint256 _quantity,\n    uint256 _pricePerItem,\n    uint256 _deadline\n  ) external offerNotExists(_nftAddress, _tokenId, msg.sender) {\n    require(\n      IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC721) ||\n        IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC1155),\n      \"invalid nft address\"\n    );\n\n    IOPGamesAuction auction = IOPGamesAuction(addressRegistry.auction());\n\n    (, , , uint256 startTime, , bool resulted) = auction.auctions(_nftAddress, _tokenId);\n\n    require(startTime == 0 || resulted == true, \"cannot place an offer if auction is going on\");\n\n    require(_deadline > _getNow(), \"invalid expiration\");\n\n    _validPayToken(address(_payToken));\n    require(address(_payToken) != address(0), \"disabled native token\");\n\n    offers[_nftAddress][_tokenId][msg.sender] = Offer(_payToken, _quantity, _pricePerItem, _deadline);\n\n    emit OfferCreated(msg.sender, _nftAddress, _tokenId, _quantity, address(_payToken), _pricePerItem, _deadline);\n  }\n\n  /**\n   * @notice Method for canceling the offer\n   * @param _nftAddress Addres of NFT contract\n   * @param _tokenId Token ID of NFT\n   */\n  function cancelOffer(address _nftAddress, uint256 _tokenId) external {\n    delete (offers[_nftAddress][_tokenId][msg.sender]);\n\n    emit OfferCanceled(msg.sender, _nftAddress, _tokenId);\n  }\n\n  /**\n   * @notice Method for accepting the offer\n   * @param _nftAddress Addres of NFT contract\n   * @param _tokenId Token ID of NFT\n   * @param _creator Offer creator address\n   */\n  function acceptOffer(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _creator\n  ) external nonReentrant offerExists(_nftAddress, _tokenId, _creator) {\n    Offer memory offer = offers[_nftAddress][_tokenId][_creator];\n\n    _validOwner(_nftAddress, _tokenId, msg.sender, offer.quantity);\n\n    uint256 price = offer.pricePerItem * offer.quantity;\n    uint256 feeAmount = (price * platformFee) / 100_0;\n\n    _tokenTransferFrom(_creator, feeRecipient, address(offer.payToken), feeAmount);\n    _tokenTransferFrom(_creator, msg.sender, address(offer.payToken), price - feeAmount);\n\n    // Transfer NFT to buyer\n    if (IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) {\n      IERC721Upgradeable(_nftAddress).safeTransferFrom(msg.sender, _creator, _tokenId);\n    } else {\n      IERC1155Upgradeable(_nftAddress).safeTransferFrom(msg.sender, _creator, _tokenId, offer.quantity, bytes(\"\"));\n    }\n\n    delete (listings[_nftAddress][_tokenId][msg.sender]);\n    delete (offers[_nftAddress][_tokenId][_creator]);\n\n    emit ItemSold(\n      msg.sender,\n      _creator,\n      _nftAddress,\n      _tokenId,\n      offer.quantity,\n      address(offer.payToken),\n      offer.pricePerItem\n    );\n\n    emit OfferCanceled(_creator, _nftAddress, _tokenId);\n  }\n\n  /**\n   @notice Update platform fee\n   @dev Only owner\n   @param _platformFee new platform fee\n   */\n  function updatePlatformFee(uint256 _platformFee) external onlyOwner {\n    require(_platformFee < 100_0, \"platform fee exceeded\");\n\n    emit PlatformFeeUpdated(msg.sender, platformFee, _platformFee);\n\n    platformFee = _platformFee;\n  }\n\n  /**\n   @notice Update platform fee address\n   @dev Only owner\n   @param _feeRecipient new platform fee recipient\n   */\n  function updatePlatformFeeRecipient(address payable _feeRecipient) external onlyOwner {\n    require(_feeRecipient != address(0), \"unexpected fee recipient\");\n\n    emit PlatformFeeRecipientUpdated(msg.sender, feeRecipient, _feeRecipient);\n\n    feeRecipient = _feeRecipient;\n  }\n\n  function _getNow() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  /**\n   * @notice Validate the collection\n   * @param _nftAddress Collection address\n   */\n  function _validCollection(address _nftAddress) internal view {\n    require(\n      (addressRegistry.tokenRegistry() != address(0) &&\n        ITokenRegistry(addressRegistry.tokenRegistry()).enabledCollection(_nftAddress)),\n      \"invalid collection\"\n    );\n  }\n\n  /**\n   * @notice Validate the payment token\n   * @dev Zero address means the native token\n   * @param _payToken Payment token address\n   */\n  function _validPayToken(address _payToken) internal view {\n    require(\n      _payToken == address(0) ||\n        (addressRegistry.tokenRegistry() != address(0) &&\n          ITokenRegistry(addressRegistry.tokenRegistry()).enabledPayToken(_payToken)),\n      \"invalid pay token\"\n    );\n  }\n\n  /**\n   * @notice Validate the NFT owner and the quantity of the item\n   * @param _nftAddress Address of NFT contract\n   * @param _tokenId Token ID of NFT\n   * @param _owner NFT onwer address to validate\n   * @param _quantity Quantity of the item\n   */\n  function _validOwner(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner,\n    uint256 _quantity\n  ) internal view {\n    if (IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC721)) {\n      IERC721Upgradeable nft = IERC721Upgradeable(_nftAddress);\n      require(nft.ownerOf(_tokenId) == _owner, \"not owning item\");\n    } else if (IERC165Upgradeable(_nftAddress).supportsInterface(INTERFACE_ID_ERC1155)) {\n      IERC1155Upgradeable nft = IERC1155Upgradeable(_nftAddress);\n      require(nft.balanceOf(_owner, _tokenId) >= _quantity, \"not owning item\");\n    } else {\n      revert(\"invalid nft address\");\n    }\n  }\n\n  function _cancelListing(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner\n  ) private {\n    Listing memory listedItem = listings[_nftAddress][_tokenId][_owner];\n\n    _validOwner(_nftAddress, _tokenId, _owner, listedItem.quantity);\n\n    delete (listings[_nftAddress][_tokenId][_owner]);\n\n    emit ItemCanceled(_owner, _nftAddress, _tokenId);\n  }\n\n  /**\n   * @notice Transfer tokens\n   * @dev If the _payToken address is zero, it means the native token\n   * @param _from Sender address\n   * @param _to Receiver address\n   * @param _payToken Payment token address\n   * @param _amount Payment token amount\n   */\n  function _tokenTransferFrom(\n    address _from,\n    address _to,\n    address _payToken,\n    uint256 _amount\n  ) private {\n    if (_payToken == address(0)) {\n      require(_from == address(this), \"invalid Ether sender\");\n\n      (bool sent, ) = payable(_to).call{value: _amount}(\"\");\n      require(sent, \"failed to send Ether\");\n    } else {\n      IERC20Upgradeable(_payToken).safeTransferFrom(_from, _to, _amount);\n    }\n  }\n\n  /**\n   * @notice Pause Marketplace\n   * @dev Only owner\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Resume Marketplace\n   * @dev Only owner\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOPGamesAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface IOPGamesAuction {\n  function auctions(address, uint256)\n    external\n    view\n    returns (\n      address,\n      address,\n      uint256,\n      uint256,\n      uint256,\n      bool\n    );\n}\n"
    },
    "contracts/interfaces/IAddressRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface IAddressRegistry {\n  function tokenRegistry() external view returns (address);\n\n  function marketplace() external view returns (address);\n\n  function auction() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ITokenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\ninterface ITokenRegistry {\n  function enabledCollection(address _nftAddress) external view returns (bool);\n\n  function enabledPayToken(address _token) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/OPGamesAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IAddressRegistry.sol\";\nimport \"./interfaces/ITokenRegistry.sol\";\n\ncontract OPGamesAuction is Initializable, OwnableUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  event AuctionCreated(address indexed nftAddress, uint256 indexed tokenId, address payToken);\n  event BidPlaced(address indexed nftAddress, uint256 indexed tokenId, address indexed bidder, uint256 bid);\n  event BidWithdrawn(address indexed nftAddress, uint256 indexed tokenId, address indexed bidder, uint256 bid);\n  event BidRefunded(address indexed nftAddress, uint256 indexed tokenId, address indexed bidder, uint256 bid);\n  event AuctionResulted(\n    address oldOwner,\n    address indexed nftAddress,\n    uint256 indexed tokenId,\n    address indexed winner,\n    address payToken,\n    uint256 winningBid\n  );\n  event AuctionCancelled(address indexed nftAddress, uint256 indexed tokenId);\n\n  /// @notice Parameters of an auction\n  struct Auction {\n    address owner;\n    address payToken;\n    uint256 minBid;\n    uint256 reservePrice;\n    uint256 startTime;\n    uint256 endTime;\n    bool resulted;\n  }\n\n  /// @notice Information about the sender that placed a bit on an auction\n  struct HighestBid {\n    address bidder;\n    uint256 bid;\n    uint256 lastBidTime;\n  }\n\n  /// @notice ERC721 Address -> Token ID -> Auction Parameters\n  mapping(address => mapping(uint256 => Auction)) public auctions;\n\n  /// @notice ERC721 Address -> Token ID -> highest bidder info (if a bid has been received)\n  mapping(address => mapping(uint256 => HighestBid)) public highestBids;\n\n  /// @notice globally and across all auctions, the amount by which a bid has to increase\n  uint256 public minBidIncrement = 1;\n\n  /// @notice Platform fee recipient\n  address payable public feeRecipient;\n\n  /// @notice Platform fee\n  uint256 public platformFee;\n\n  /// @notice AddressRegistry\n  IAddressRegistry public addressRegistry;\n\n  receive() external payable {}\n\n  function initialize(\n    address _addressRegistry,\n    address payable _feeRecipient,\n    uint256 _platformFee\n  ) external initializer {\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    __Pausable_init();\n\n    require(_addressRegistry != address(0), \"unexpected address registry\");\n    require(_feeRecipient != address(0), \"unexpected fee recipient\");\n    require(_platformFee < 100_0, \"platform fee exceeded\");\n\n    addressRegistry = IAddressRegistry(_addressRegistry);\n    feeRecipient = _feeRecipient;\n    platformFee = _platformFee;\n  }\n\n  /**\n   * @notice Creates a new auction for a given item\n   * @dev Only the owner of item can create an auction and must have approved the contract\n   * @dev In addition to owning the item, the sender also has to have the MINTER role.\n   * @dev End time for the auction must be in the future.\n   * @param _nftAddress ERC 721 Address\n   * @param _tokenId Token ID of the item being auctioned\n   * @param _payToken Paying token\n   * @param _reservePrice Item cannot be sold for less than this or minBidIncrement, whichever is higher\n   * @param _startTimestamp Unix epoch in seconds for the auction start time\n   * @param _minBidReserve Whether the reserve price should be applied or not\n   * @param _endTimestamp Unix epoch in seconds for the auction end time.\n   */\n  function createAuction(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _payToken,\n    uint256 _reservePrice,\n    uint256 _startTimestamp,\n    bool _minBidReserve,\n    uint256 _endTimestamp\n  ) external whenNotPaused {\n    // Ensure this contract is approved to move the token\n    require(\n      IERC721Upgradeable(_nftAddress).ownerOf(_tokenId) == msg.sender &&\n        IERC721Upgradeable(_nftAddress).isApprovedForAll(msg.sender, address(this)),\n      \"not owner and or contract not approved\"\n    );\n\n    _validCollection(_nftAddress);\n    _validPayToken(_payToken);\n\n    _createAuction(_nftAddress, _tokenId, _payToken, _reservePrice, _startTimestamp, _minBidReserve, _endTimestamp);\n  }\n\n  /**\n   * @notice Places a new bid, out bidding the existing bidder if found and criteria is reached\n   * @dev Only callable when the auction is open\n   * @dev Bids from smart contracts are prohibited to prevent griefing with always reverting receiver\n   * @param _nftAddress ERC 721 Address\n   * @param _tokenId Token ID of the item being auctioned\n   * @param _bidAmount Bid amount\n   */\n  function placeBid(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _bidAmount\n  ) external payable nonReentrant whenNotPaused {\n    require(msg.sender == tx.origin, \"no contracts permitted\");\n\n    // Check the auction to see if this is a valid bid\n    Auction memory auction = auctions[_nftAddress][_tokenId];\n\n    // Ensure auction is in flight\n    require(_getNow() >= auction.startTime && _getNow() <= auction.endTime, \"bidding outside of the auction window\");\n\n    _placeBid(_nftAddress, _tokenId, _bidAmount);\n  }\n\n  function _placeBid(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _bidAmount\n  ) internal whenNotPaused {\n    Auction storage auction = auctions[_nftAddress][_tokenId];\n\n    if (auction.minBid == auction.reservePrice) {\n      require(_bidAmount >= auction.reservePrice, \"bid cannot be lower than reserve price\");\n    }\n\n    // Ensure bid adheres to outbid increment and threshold\n    HighestBid storage highestBid = highestBids[_nftAddress][_tokenId];\n    uint256 minBidRequired = highestBid.bid + minBidIncrement;\n\n    require(_bidAmount >= minBidRequired, \"failed to outbid highest bidder\");\n    _tokenTransferFrom(msg.sender, address(this), auction.payToken, _bidAmount);\n\n    // Refund existing top bidder if found\n    if (highestBid.bidder != address(0)) {\n      _refundHighestBidder(_nftAddress, _tokenId, highestBid.bidder, highestBid.bid);\n    }\n\n    // assign top bidder and bid time\n    highestBid.bidder = msg.sender;\n    highestBid.bid = _bidAmount;\n    highestBid.lastBidTime = _getNow();\n\n    emit BidPlaced(_nftAddress, _tokenId, msg.sender, _bidAmount);\n  }\n\n  /**\n   * @notice Allows the hightest bidder to withdraw the bid (after 12 hours post auction's end)\n   * @dev Only callable by the existing top bidder\n   * @param _nftAddress ERC 721 Address\n   * @param _tokenId Token ID of the item being auctioned\n   */\n  function withdrawBid(address _nftAddress, uint256 _tokenId) external nonReentrant {\n    HighestBid storage highestBid = highestBids[_nftAddress][_tokenId];\n\n    // Ensure highest bidder is the caller\n    require(highestBid.bidder == msg.sender, \"you are not the highest bidder\");\n\n    uint256 _endTime = auctions[_nftAddress][_tokenId].endTime;\n\n    require(\n      _getNow() > _endTime && (_getNow() - _endTime >= 43200),\n      \"can withdraw only after 12 hours (after auction ended)\"\n    );\n\n    uint256 previousBid = highestBid.bid;\n\n    // Clean up the existing top bid\n    delete highestBids[_nftAddress][_tokenId];\n\n    // Refund the top bidder\n    _refundHighestBidder(_nftAddress, _tokenId, msg.sender, previousBid);\n\n    emit BidWithdrawn(_nftAddress, _tokenId, msg.sender, previousBid);\n  }\n\n  /**\n   * @notice Closes a finished auction and rewards the highest bidder\n   * @dev Only admin or smart contract\n   * @dev Auction can only be resulted if there has been a bidder and reserve met.\n   * @dev If there have been no bids, the auction needs to be cancelled instead using `cancelAuction()`\n   * @param _nftAddress ERC 721 Address\n   * @param _tokenId Token ID of the item being auctioned\n   */\n  function resultAuction(address _nftAddress, uint256 _tokenId) external nonReentrant whenNotPaused {\n    // Check the auction to see if it can be resulted\n    Auction storage auction = auctions[_nftAddress][_tokenId];\n\n    require(\n      IERC721Upgradeable(_nftAddress).ownerOf(_tokenId) == msg.sender && msg.sender == auction.owner,\n      \"sender must be item owner\"\n    );\n\n    // Check the auction real\n    require(auction.endTime > 0, \"no auction exists\");\n\n    // Check the auction has ended\n    require(_getNow() > auction.endTime, \"auction not ended\");\n\n    // Ensure auction not already resulted\n    require(!auction.resulted, \"auction already resulted\");\n\n    // Get info on who the highest bidder is\n    HighestBid storage highestBid = highestBids[_nftAddress][_tokenId];\n    address winner = highestBid.bidder;\n    uint256 winningBid = highestBid.bid;\n\n    // Ensure there is a winner\n    require(winner != address(0), \"no open bids\");\n    require(winningBid >= auction.reservePrice, \"highest bid is below reservePrice\");\n\n    // Ensure this contract is approved to move the token\n    require(IERC721Upgradeable(_nftAddress).isApprovedForAll(msg.sender, address(this)), \"auction not approved\");\n\n    // Result the auction\n    auction.resulted = true;\n\n    // Clean up the highest bid\n    delete highestBids[_nftAddress][_tokenId];\n\n    uint256 feeAmount = (winningBid * platformFee) / 100_0;\n\n    IERC20Upgradeable payToken = IERC20Upgradeable(auction.payToken);\n    payToken.safeTransfer(feeRecipient, feeAmount);\n    payToken.safeTransfer(auction.owner, winningBid - feeAmount);\n\n    // Transfer the token to the winner\n    IERC721Upgradeable(_nftAddress).safeTransferFrom(\n      IERC721Upgradeable(_nftAddress).ownerOf(_tokenId),\n      winner,\n      _tokenId\n    );\n\n    // Remove auction\n    delete auctions[_nftAddress][_tokenId];\n\n    emit AuctionResulted(msg.sender, _nftAddress, _tokenId, winner, auction.payToken, winningBid);\n  }\n\n  /**\n   * @notice Private method doing the heavy lifting of creating an auction\n   * @param _nftAddress ERC 721 Address\n   * @param _tokenId Token ID of the NFT being auctioned\n   * @param _payToken Paying token\n   * @param _reservePrice Item cannot be sold for less than this or minBidIncrement, whichever is higher\n   * @param _startTimestamp Unix epoch in seconds for the auction start time\n   * @param _endTimestamp Unix epoch in seconds for the auction end time.\n   */\n  function _createAuction(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _payToken,\n    uint256 _reservePrice,\n    uint256 _startTimestamp,\n    bool minBidReserve,\n    uint256 _endTimestamp\n  ) private {\n    // Ensure a token cannot be re-listed if previously successfully sold\n    require(auctions[_nftAddress][_tokenId].endTime == 0, \"auction already started\");\n\n    // Check end time not before start time and that end is in the future\n    require(_endTimestamp >= _startTimestamp + 300, \"end time must be greater than start (by 5 minutes)\");\n\n    require(_startTimestamp > _getNow(), \"invalid start time\");\n\n    uint256 minimumBid = 0;\n\n    if (minBidReserve) {\n      minimumBid = _reservePrice;\n    }\n\n    // Setup the auction\n    auctions[_nftAddress][_tokenId] = Auction({\n      owner: msg.sender,\n      payToken: _payToken,\n      minBid: minimumBid,\n      reservePrice: _reservePrice,\n      startTime: _startTimestamp,\n      endTime: _endTimestamp,\n      resulted: false\n    });\n\n    emit AuctionCreated(_nftAddress, _tokenId, _payToken);\n  }\n\n  /**\n   * @notice Cancels and inflight and un-resulted auctions, returning the funds to the top bidder if found\n   * @dev Only item owner\n   * @param _nftAddress ERC 721 Address\n   * @param _tokenId Token ID of the NFT being auctioned\n   */\n  function cancelAuction(address _nftAddress, uint256 _tokenId) external nonReentrant {\n    // Check valid and not resulted\n    Auction memory auction = auctions[_nftAddress][_tokenId];\n\n    require(\n      IERC721Upgradeable(_nftAddress).ownerOf(_tokenId) == msg.sender && msg.sender == auction.owner,\n      \"sender must be owner\"\n    );\n\n    // Check auction is real\n    require(auction.endTime > 0, \"no auction exists\");\n\n    // Check auction not already resulted\n    require(!auction.resulted, \"auction already resulted\");\n\n    _cancelAuction(_nftAddress, _tokenId);\n  }\n\n  function _cancelAuction(address _nftAddress, uint256 _tokenId) private {\n    // refund existing top bidder if found\n    HighestBid storage highestBid = highestBids[_nftAddress][_tokenId];\n    if (highestBid.bidder != address(0)) {\n      _refundHighestBidder(_nftAddress, _tokenId, highestBid.bidder, highestBid.bid);\n\n      // Clear up highest bid\n      delete highestBids[_nftAddress][_tokenId];\n    }\n\n    // Remove auction and top bidder\n    delete auctions[_nftAddress][_tokenId];\n\n    emit AuctionCancelled(_nftAddress, _tokenId);\n  }\n\n  /**\n   * @notice Used for sending back escrowed funds from a previous bid\n   * @param _currentHighestBidder Address of the last highest bidder\n   * @param _currentHighestBid Ether or Mona amount in WEI that the bidder sent when placing their bid\n   */\n  function _refundHighestBidder(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _currentHighestBidder,\n    uint256 _currentHighestBid\n  ) private {\n    Auction memory auction = auctions[_nftAddress][_tokenId];\n\n    _tokenTransferFrom(address(this), _currentHighestBidder, auction.payToken, _currentHighestBid);\n\n    emit BidRefunded(_nftAddress, _tokenId, _currentHighestBidder, _currentHighestBid);\n  }\n\n  /**\n   * @notice Validate the payment token\n   * @dev Zero address means the native token\n   * @param _payToken Payment token address\n   */\n  function _validPayToken(address _payToken) internal view {\n    require(\n      _payToken == address(0) ||\n        (addressRegistry.tokenRegistry() != address(0) &&\n          ITokenRegistry(addressRegistry.tokenRegistry()).enabledPayToken(_payToken)),\n      \"invalid pay token\"\n    );\n  }\n\n  /**\n   * @notice Validate the collection\n   * @param _nftAddress Collection address\n   */\n  function _validCollection(address _nftAddress) internal view {\n    require(\n      (addressRegistry.tokenRegistry() != address(0) &&\n        ITokenRegistry(addressRegistry.tokenRegistry()).enabledCollection(_nftAddress)),\n      \"invalid collection\"\n    );\n  }\n\n  /**\n   * @notice Transfer tokens\n   * @dev If the _payToken address is zero, it means the native token\n   * @param _from Sender address\n   * @param _to Receiver address\n   * @param _payToken Payment token address\n   * @param _amount Payment token amount\n   */\n  function _tokenTransferFrom(\n    address _from,\n    address _to,\n    address _payToken,\n    uint256 _amount\n  ) private {\n    if (_payToken == address(0)) {\n      require(_from == address(this), \"invalid Ether sender\");\n\n      (bool sent, ) = payable(_to).call{value: _amount}(\"\");\n      require(sent, \"failed to send Ether\");\n    } else {\n      IERC20Upgradeable(_payToken).safeTransferFrom(_from, _to, _amount);\n    }\n  }\n\n  function _getNow() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  /**\n   * @notice Pause Auction\n   * @dev Only owner\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice Resume Auction\n   * @dev Only owner\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}